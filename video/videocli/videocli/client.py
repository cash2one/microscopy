#!/usr/bin/python
# 
# Copyright 2014 University of Southern California
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
Raw network client for HTTP(S) communication with ERMREST service.
"""

import os
import subprocess
import hashlib
import json
import base64
import urlparse
from httplib import HTTPConnection, HTTPSConnection, HTTPException, OK, CREATED, ACCEPTED, NO_CONTENT, CONFLICT, FORBIDDEN, INTERNAL_SERVER_ERROR, SERVICE_UNAVAILABLE, BadStatusLine, CannotSendRequest, GATEWAY_TIMEOUT, METHOD_NOT_ALLOWED, NOT_FOUND
import sys
import traceback
import time
import shutil
import smtplib
import urllib
import re
import mimetypes
from email.mime.text import MIMEText
import socket
from dateutil.parser import parse
mail_footer = 'Do not reply to this message.  This is an automated message generated by the system, which does not receive email messages.'

class ErmrestHTTPException(Exception):
    def __init__(self, value, status, retry=False):
        super(ErmrestHTTPException, self).__init__(value)
        self.value = value
        self.status = status
        self.retry = retry
        
    def __str__(self):
        message = "%s." % self.value
        return message

class ErmrestException(Exception):
    def __init__(self, value, cause=None):
        super(ErmrestException, self).__init__(value)
        self.value = value
        self.cause = cause
        
    def __str__(self):
        message = "%s." % self.value
        if self.cause:
            message += " Caused by: %s." % self.cause
        return message

class MalformedURL(ErmrestException):
    """MalformedURL indicates a malformed URL.
    """
    def __init__(self, cause=None):
        super(MalformedURL, self).__init__("URL was malformed", cause)

class UnresolvedAddress(ErmrestException):
    """UnresolvedAddress indicates a failure to resolve the network address of
    the Ermrest service.
    
    This error is raised when a low-level socket.gaierror is caught.
    """
    def __init__(self, cause=None):
        super(UnresolvedAddress, self).__init__("Could not resolve address of host", cause)

class NetworkError(ErmrestException):
    """NetworkError wraps a socket.error exception.
    
    This error is raised when a low-level socket.error is caught.
    """
    def __init__(self, cause=None):
        super(NetworkError, self).__init__("Network I/O failure", cause)

class ProtocolError(ErmrestException):
    """ProtocolError indicates a protocol-level failure.
    
    In other words, you may have tried to add a tag for which no tagdef exists.
    """
    def __init__(self, message='Network protocol failure', errorno=-1, response=None, cause=None):
        super(ProtocolError, self).__init__("Ermrest protocol failure", cause)
        self._errorno = errorno
        self._response = response
        
    def __str__(self):
        message = "%s." % self.value
        if self._errorno >= 0:
            message += " HTTP ERROR %d: %s" % (self._errorno, self._response)
        return message
    
class NotFoundError(ErmrestException):
    """Raised for HTTP NOT_FOUND (i.e., ERROR 404) responses."""
    pass


class ErmrestClient (object):
    """Network client for ERMREST.
    """
    ## Derived from the ermrest iobox service client

    def __init__(self, **kwargs):
        self.baseuri = kwargs.get("baseuri")
        o = urlparse.urlparse(self.baseuri)
        self.scheme = o[0]
        host_port = o[1].split(":")
        self.host = host_port[0]
        self.path = o.path
        self.port = None
        if len(host_port) > 1:
            self.port = host_port[1]
        self.mail_server = kwargs.get("mail_server")
        self.mail_sender = kwargs.get("mail_sender")
        self.mail_receiver = kwargs.get("mail_receiver")
        self.logger = kwargs.get("logger")
        self.watermark = kwargs.get("watermark")
        self.ffmpeg = kwargs.get("ffmpeg")
        self.video_resources = kwargs.get("video_resources")
        self.data_scratch = kwargs.get("data_scratch")
        self.timeout = kwargs.get("timeout") * 60
        self.cookie = kwargs.get("cookie")
        self.chunk_size = kwargs.get("chunk_size")
        self.header = None
        self.webconn = None
        self.logger.debug('Client initialized.')

    def send_request(self, method, url, body='', headers={}, sendData=False, ignoreErrorCodes=[]):
        try:
            request_headers = headers.copy()
            url = self.url_cid(url)
            if self.header:
                headers.update(self.header)
            self.logger.debug('Sending request: method="%s", url="%s://%s%s", headers="%s"' % (method, self.scheme, self.host, url, request_headers))
            retry = False
            try:
                if sendData == False:
                    self.webconn.request(method, url, body, headers)
                else:
                    """ 
                    For file upload send the request step by step 
                    """
                    self.webconn.putrequest(method, url)
                    for key,value in headers.iteritems():
                        self.webconn.putheader(key,value)
                    self.webconn.endheaders()
                    self.webconn.send(body)
                resp = self.webconn.getresponse()
                self.logger.debug('Response: %d' % resp.status)
            except socket.error, e:
                retry = True
                self.logger.debug('Socket error: %d' % (e.errno))
            except (BadStatusLine, CannotSendRequest):
                retry = True
            except:
                raise
            if retry:
                """ 
                Resend the request 
                """
                self.close()
                self.connect()
                self.sendMail('WARNING Video: The HTTPSConnection has been restarted', 'The HTTPSConnection has been restarted on "%s://%s".\n' % (self.scheme, self.host))
                self.logger.debug('Resending request: method="%s", url="%s://%s%s"' % (method, self.scheme, self.host, url))
                if sendData == False:
                    self.webconn.request(method, url, body, headers)
                else:
                     self.webconn.putrequest(method, url)
                     for key,value in headers.iteritems():
                         self.webconn.putheader(key,value)
                     self.webconn.endheaders()
                     self.webconn.send(body)
                resp = self.webconn.getresponse()
                self.logger.debug('Response: %d' % resp.status)
            if resp.status in [INTERNAL_SERVER_ERROR, SERVICE_UNAVAILABLE, GATEWAY_TIMEOUT]:
                """ 
                Resend the request 
                """
                self.close()
                self.connect()
                self.sendMail('WARNING Video: The HTTPSConnection has been restarted', 'HTTP exception: %d.\nThe HTTPSConnection has been restarted on "%s://%s".\n' % (resp.status, self.scheme, self.host))
                self.logger.debug('Resending request: method="%s", url="%s://%s%s", headers="%s"' % (method, self.scheme, self.host, url, request_headers))
                if sendData == False:
                    self.webconn.request(method, url, body, headers)
                else:
                     self.webconn.putrequest(method, url)
                     for key,value in headers.iteritems():
                         self.webconn.putheader(key,value)
                     self.webconn.endheaders()
                     self.webconn.send(body)
                resp = self.webconn.getresponse()
                self.logger.debug('Response: %d' % resp.status)
            if resp.status not in [OK, CREATED, ACCEPTED, NO_CONTENT]:
                errmsg = resp.read()
                if resp.status not in ignoreErrorCodes:
                    self.logger.error('Error response: method="%s", url="%s://%s%s", status=%i, error: %s' % (method, self.scheme, self.host, url, resp.status, errmsg))
                else:
                    self.logger.error('Error response: %s' % (errmsg))
                raise ErmrestHTTPException("Error response (%i) received: %s" % (resp.status, errmsg), resp.status, retry)
            return resp
        except ErmrestHTTPException:
            raise
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got HTTP exception: method="%s", url="%s://%s%s", error="%s"' % (method, self.scheme, self.host, url, str(ev)))
            self.logger.error('%s' % str(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Video: Unexpected Exception', 'Error generated during the HTTP request: method="%s", url="%s://%s%s", error="\n%s\n%s"' % (method, self.scheme, self.host, url, str(ev), ''.join(traceback.format_exception(et, ev, tb))))
            raise

    def connect(self, reconnect=False):
        if self.scheme == 'https':
            self.webconn = HTTPSConnection(host=self.host, port=self.port)
        elif self.scheme == 'http':
            self.webconn = HTTPConnection(host=self.host, port=self.port)
        else:
            raise ValueError('Scheme %s is not supported.' % self.scheme)

        """
        if self.use_goauth:
            auth = base64.encodestring('%s:%s' % (self.username, self.password)).replace('\n', '')
            headers = dict(Authorization='Basic %s' % auth)
            resp = self.send_request('GET', '/service/nexus/goauth/token?grant_type=client_credentials', '', headers, reconnect)
            goauth = json.loads(resp.read())
            self.access_token = goauth['access_token']
            self.header = dict(Authorization='Globus-Goauthtoken %s' % self.access_token)
        else:
            #headers = {}
            #headers["Content-Type"] = "application/x-www-form-urlencoded"
            #resp = self.send_request("POST", "/ermrest/authn/session", "username=%s&password=%s" % (self.username, self.password), headers, reconnect)
            #self.header = dict(Cookie=resp.getheader("set-cookie"))
        """
        self.header = {'Cookie': self.cookie}
        
    def close(self):
        """Closes the connection to the Ermrest service.
        
        The underlying python documentation is not very helpful but it would
        appear that the HTTP[S]Connection.close() could raise a socket.error.
        Thus, this method potentially raises a 'NetworkError'.
        """
        assert self.webconn
        try:
            self.webconn.close()
        except socket.error as e:
            raise NetworkError(e)
        finally:
            self.webconn = None

    def sendMail(self, subject, text):
        if self.mail_server and self.mail_sender and self.mail_receiver:
            retry = 0
            ready = False
            while not ready:
                try:
                    msg = MIMEText('%s\n\n%s' % (text, mail_footer), 'plain')
                    msg['Subject'] = subject
                    msg['From'] = self.mail_sender
                    msg['To'] = self.mail_receiver
                    s = smtplib.SMTP(self.mail_server)
                    s.sendmail(self.mail_sender, self.mail_receiver.split(','), msg.as_string())
                    s.quit()
                    self.logger.debug('Sent email notification.')
                    ready = True
                except socket.gaierror as e:
                    if e.errno == socket.EAI_AGAIN:
                        time.sleep(100)
                        retry = retry + 1
                        ready = retry > 10
                    else:
                        ready = True
                    if ready:
                        et, ev, tb = sys.exc_info()
                        self.logger.error('got exception "%s"' % str(ev))
                        self.logger.error('%s' % str(traceback.format_exception(et, ev, tb)))
                except:
                    et, ev, tb = sys.exc_info()
                    self.logger.error('got exception "%s"' % str(ev))
                    self.logger.error('%s' % str(traceback.format_exception(et, ev, tb)))
                    ready = True

    def start(self):
        self.connect()
        try:
            self.processVideo()
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % str(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Video Processing: unexpected exception', '%s\nThe process might have been stopped\n' % str(traceback.format_exception(et, ev, tb)))
            raise
        
    def processVideo(self):
        transcode_only = os.getenv('TRANSCODE_ONLY', 'f').lower() in ['t', 'true']
        self.logger.debug('TRANSCODE_ONLY: %s.' % (transcode_only)) 
        url = '%s/entity/Immunofluorescence:Slide_Video/!Bytes::null::&Media_Type=video%%2Fmp4&MP4_URI::null::&Processing_Status::null::' % (self.path)
        headers = {'Content-Type': 'application/json', 'Accept': 'application/json'}
        resp = self.send_request('GET', url, '', headers, False)
        movies = json.loads(resp.read())
        movieids = []
        for movie in movies:
            movieids.append((movie['Accession_ID'], movie['Name'], movie['MD5'], movie['Identifier']))
                
        self.logger.debug('Processing %d video(s).' % (len(movieids))) 
        for movieId,fileName,md5,uri in movieids:
            #year = parse(rct).strftime("%Y")
            f = self.getMovieFile(fileName, uri)
            if f == None:
                self.reportFailure(movieId, 'error')
                continue
                
            self.logger.debug('Transcoding and adding watermark to the video "%s"' % (fileName))
            
            try:
                #args = [self.ffmpeg, '-y', '-i', f, '-i', self.watermark, '-filter_complex', 'overlay=x=(main_w-overlay_w):y=0', '%s/%s' % (self.data_scratch, fileName)]
                if transcode_only == True:
                    args = [self.ffmpeg, '-y', '-i', f, '-vcodec', 'libx264', '-pix_fmt', 'yuv420p', '%s/%s' % (self.data_scratch, fileName)]
                else:
                    args = [self.ffmpeg, '-y', '-i', f, '-i', self.watermark, '-vcodec', 'libx264', '-pix_fmt', 'yuv420p', '-filter_complex', 'pad=width=iw:height=ih+90:color=#71cbf4,overlay=(main_w-overlay_w)/2:main_h-90', '%s/%s' % (self.data_scratch, fileName)]
                p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                stdoutdata, stderrdata = p.communicate()
                returncode = p.returncode
            except:
                et, ev, tb = sys.exc_info()
                self.logger.error('got unexpected exception "%s"' % str(ev))
                self.logger.error('%s' % str(traceback.format_exception(et, ev, tb)))
                self.sendMail('FAILURE Video: ffmpeg ERROR', '%s\n' % str(traceback.format_exception(et, ev, tb)))
                returncode = 1
            
            if returncode != 0:
                self.logger.error('Can not transcode and add watermark to the "%s" file.\nstdoutdata: %s\nstderrdata: %s\n' % (fileName, stdoutdata, stderrdata)) 
                self.sendMail('FAILURE Video', 'Can not transcode and add watermark to the "%s" file.\nstdoutdata: %s\nstderrdata: %s\n' % (fileName, stdoutdata, stderrdata))
                os.remove(f)
                try:
                    os.remove('%s/%s' % (self.data_scratch, fileName))
                except:
                    et, ev, tb = sys.exc_info()
                    self.logger.error('Can not remove file "%s/%s"\n%s"' % (self.data_scratch, fileName, str(ev)))
                    self.logger.error('%s' % str(traceback.format_exception(et, ev, tb)))
                """
                Update the Slide_Video table with the failure result.
                """
                self.reportFailure(movieId, 'error')
                continue
                
            if transcode_only == True:
                self.logger.debug('Uploading in hatrac the transcoded movie file "%s".' % (fileName)) 
            else:
                self.logger.debug('Uploading in hatrac the transcoded movie file "%s" with the watermark.' % (fileName)) 
            newFile = '%s/%s' % (self.data_scratch, fileName)
            file_size = os.path.getsize(newFile)
            new_md5sum = self.md5sum(newFile, self.chunk_size)
            new_md5 = self.md5hex(newFile)
            new_sha256 = self.sha256sum(newFile)
            new_uri = '%s%s' % (uri[0:-len(md5)], new_md5)
            metadata = {"content_disposition": "filename*=UTF-8''%s" % fileName}
            
            """
            Check if this file exists in hatrac
            """
            if self.get_md5sum(new_uri) == new_md5sum:
                self.logger.info('Skipping the upload of the file "%s" as it already exists hatrac.' % fileName)
                os.remove(newFile)
            else:
                try:
                    self.uploadFile(new_uri, newFile, self.chunk_size, metadata)
                    os.remove(newFile)
                except:
                    et, ev, tb = sys.exc_info()
                    self.logger.error('Can not transfer file "%s" in namespace "%s". Error: "%s"' % (fileName, new_uri, str(ev)))
                    self.sendMail('Failure Video: HATRAC Error', 'Can not upload file "%s" in namespace "%s". Error: "%s"' % (fileName, new_uri, str(ev)))
                    self.reportFailure(movieId, 'error')
                    os.remove(newFile)
                    os.remove(f)
                    continue

            columns = ["MP4_URI", "Bytes", "MD5", "SHA256", "Processing_Status"]
            
            os.remove(f)
            columns = ','.join([urllib.quote(col, safe='') for col in columns])
            url = '%s/attributegroup/Immunofluorescence:Slide_Video/Accession_ID;%s' % (self.path, columns)
            body = []
            obj = {'Accession_ID': movieId,
                   'MP4_URI': new_uri,
                   'Bytes': file_size,
                   'MD5': new_md5,
                   'SHA256': new_sha256,
                   "Processing_Status": 'success'
                   }
            body.append(obj)
            headers = {'Content-Type': 'application/json'}
            resp = self.send_request('PUT', url, json.dumps(body), headers, False)
            resp.read()
            self.logger.debug('SUCCEEDED updated the entry for the "%s" file.' % (fileName)) 
        self.logger.debug('Ended Transcoding and Adding Watermarkers.') 
        
    """
    Upload a file.
    """
    def uploadFile(self, object_url, filePath, chunk_size, metadata):
        try:
            job_id = self.createUploadJob(object_url, filePath, chunk_size, metadata)
            self.chunksUpload(object_url, filePath, job_id, chunk_size)
            self.chunksUploadFinalization(object_url, job_id)
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('Can not upload file "%s" in namespace "%s://%s%s". Error: "%s"' % (filePath, self.scheme, self.host, object_url, str(ev)))
            raise

    """
    Get the base64 digest string like sha256 utility would compute.
    """
    def sha256base64(self, fpath, chunk_size):
        h = hashlib.sha256()
        try:
            f = open(fpath, 'rb')
            try:
                b = f.read(chunk_size)
                while b:
                    h.update(b)
                    b = f.read(chunk_size)
                return base64.b64encode(h.digest())
            finally:
                f.close()
        except:
            return None

    """
    Encode the content-disposition.
    """
    def encode_disposition(self, orig):
        m = re.match("^filename[*]=UTF-8''(?P<name>[-_.~A-Za-z0-9%]+)$", orig)
        if m:
            return orig
        elif not orig.startswith("filename*=UTF-8''"):
            raise ValueError('Cannot accept content-disposition "%s"; it must start with "filename*=UTF-8\'\'".' % orig)
        else:
            ret = ["filename*=UTF-8''"]
            for c in orig[len("filename*=UTF-8''"):]:
                m = m = re.match("(?P<name>[-_.~A-Za-z0-9%]+)$", c)
                if m:
                    ret.append(c)
                else:
                    #In case we want an URL encoding
                    #ret.append('%%%s' % c.encode('hex').upper())
                    ret.append('_')
            return ''.join(ret)

    """
    Create a job for uploading a file.
    """
    def createUploadJob(self, object_url, filePath, chunk_size, metadata):
        try:
            md5,sha256 = self.content_checksum(filePath, chunk_size)
            content_checksum = {"content-md5": md5,
                              "content-sha256": sha256}
            content_disposition = metadata.get('content_disposition', None)
            file_size = os.path.getsize(filePath)
            url = '%s;upload' % object_url
            headers = {'Content-Type': 'application/json'}
            if mimetypes.inited == False:
                mimetypes.init()
            content_type,encoding = mimetypes.guess_type(filePath)
            if content_type == None:
                content_type = 'application/octet-stream'
            obj = {"chunk-length": chunk_size,
                   "content-length": file_size,
                   "content-type": content_type}
            obj.update(content_checksum)
            if content_disposition != None:
                obj['content-disposition'] = self.encode_disposition(content_disposition)
            self.logger.debug('hatrac metadata: "%s"\n' % (json.dumps(obj)))
            resp = self.send_request('POST', url, body=json.dumps(obj), headers=headers)
            res = resp.read()
            job_id = res.split('/')[-1][:-1]
            self.logger.debug('Created job_id "%s" for url "%s://%s%s".' % (job_id, self.scheme, self.host, url))
            return job_id
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('Can not create job for uploading file "%s" in object "%s://%s%s". Error: "%s"' % (filePath, self.scheme, self.host, object_url, str(ev)))
            raise

    """
    Upload a file through chunks.
    """
    def chunksUpload(self, object_url, filePath, job_id, chunk_size):
        try:
            file_size = os.path.getsize(filePath)
            chunk_no = file_size / chunk_size
            last_chunk_size = file_size % chunk_size
            f = open(filePath, "rb")
            for index in range(chunk_no):
                position = index
                body = f.read(chunk_size)
                url = '%s;upload/%s/%d' % (object_url, job_id, position)
                headers = {'Content-Type': 'application/octet-stream', 'Content-Length': '%d' % chunk_size}
                resp = self.send_request('PUT', url, body=body, headers=headers, sendData=True)
                res = resp.read()
            if last_chunk_size > 0:
                position = chunk_no
                body = f.read(chunk_size)
                url = '%s;upload/%s/%d' % (object_url, job_id, position)
                headers = {'Content-Type': 'application/octet-stream', 'Content-Length': '%d' % last_chunk_size}
                resp = self.send_request('PUT', url, body=body, headers=headers, sendData=True)
                res = resp.read()
            f.close()
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('Can not upload chunk for file "%s" in namespace "%s://%s%s" and job_id "%s". Error: "%s"' % (filePath, self.scheme, self.host, url, job_id, str(ev)))
            try:
                f.close()
                self.cancelJob(object_url, job_id)
            except:
                pass
            raise
            

    """
    Cancel a job.
    """
    def cancelJob(self, object_url, job_id):
        try:
            url = '%s;upload/%s' % (object_url, job_id)
            headers = {}
            resp = self.send_request('DELETE', url, headers=headers)
            res = resp.read()
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('Can not cancel job "%s" for object "%s://%s%s". Error: "%s"' % (job_id, self.scheme, self.host, url, str(ev)))
            raise
            
    """
    Finalize the chunks upload.
    """
    def chunksUploadFinalization(self, object_url, job_id):
        try:
            url = '%s;upload/%s' % (object_url, job_id)
            headers = {}
            resp = self.send_request('POST', url, headers=headers)
            res = resp.read()
            return res
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('Can not finalize job "%s" for object "%s://%s%s". Error: "%s"' % (job_id, self.scheme, self.host, url, str(ev)))
            raise
            
    """
    Get the hexa md5 checksum of the file.
    """
    def md5hex(self, fpath):
        h = hashlib.md5()
        try:
            f = open(fpath, 'rb')
            try:
                b = f.read(4096)
                while b:
                    h.update(b)
                    b = f.read(4096)
                return h.hexdigest()
            finally:
                f.close()
        except:
            return None

    """
    Get the checksum of the file.
    """
    def sha256sum(self, fpath):
        h = hashlib.sha256()
        try:
            f = open(fpath, 'rb')
            try:
                b = f.read(4096)
                while b:
                    h.update(b)
                    b = f.read(4096)
                return h.hexdigest()
            finally:
                f.close()
        except:
            return None

    """
    Get the md5sum file from hatrac.
    """
    def get_md5sum(self, url):
        """
            Retrieve the md5sum of a file
        """
        ret = None
        if url != None:
            headers = {'Accept': '*'}
            try:
                resp = self.send_request('HEAD', url, '', headers=headers, ignoreErrorCodes=[NOT_FOUND])
                resp.read()
                ret = resp.getheader('content-md5', None)
            except:
                pass
        return ret
                
    def reportFailure(self, movieId, error_message):
        """
            Update the Slide_Video table with the transcode/watermark failure result.
        """
        try:
            columns = ["Processing_Status"]
            columns = ','.join([urllib.quote(col, safe='') for col in columns])
            url = '%s/attributegroup/Immunofluorescence:Slide_Video/Accession_ID;%s' % (self.path, columns)
            body = []
            obj = {'Accession_ID': movieId,
                   "Processing_Status": '%s' % error_message
                   }
            body.append(obj)
            headers = {'Content-Type': 'application/json'}
            resp = self.send_request('PUT', url, json.dumps(body), headers, False)
            resp.read()
            self.logger.debug('SUCCEEDED updated the Slide_Video table for the movie Accession_ID "%s"  with the Processing_Status result "%s".' % (movieId, error_message)) 
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % str(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Video: reportFailure ERROR', '%s\n' % str(traceback.format_exception(et, ev, tb)))
            
        
    def getMovieFile(self, fileName, uri):
        try:
            self.logger.debug('Processing file: "%s".' % (fileName)) 
            movieFile = '%s/original_%s' % (self.data_scratch, fileName)
            url = '%s' % (uri)
            headers = {'Accept': '*'}
            resp = self.send_request('GET', url, '', headers, False)
            self.logger.debug('content-length: %s.' % (resp.getheader('content-length'))) 
            #self.logger.debug('response headers: %s.' % (resp.getheaders())) 
            block_sz = 8192
            f = open(movieFile, 'wb')
            while True:
                buffer = resp.read(block_sz)
                if not buffer:
                    break
                f.write(buffer)
            f.close()
            self.logger.debug('File "%s", %d bytes.' % (movieFile, os.stat(movieFile).st_size)) 
            return movieFile
            """
            url = '%s' % (uri)
            headers = {'Accept': '*'}
            resp = self.send_request('HEAD', url, '', headers, False)
            resp.read()
            content_location = resp.getheader('content-location', None)
            if content_location != None:
                self.logger.debug('content_location: %s.' % (content_location)) 
                srcFile = urllib.unquote('%s%s'  % (self.video_resources, content_location))
                shutil.copyfile(srcFile, movieFile)
                return movieFile
            else:
                self.logger.error('Can not get video file "%s"."%s"' % (fileName))
                self.sendMail('FAILURE Video: reportFailure ERROR', 'Can not get hatrac location for the file "%s".' % fileName)
                return None
            """
                
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('Can not get video file "%s"\n"%s"' % (fileName, str(ev)))
            self.logger.error('%s' % str(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Video: reportFailure ERROR', '%s\n' % str(traceback.format_exception(et, ev, tb)))
            return None

    """
    Get the base64 digest string like md5 utility would compute.
    """
    def md5sum(self, fpath, chunk_size):
        h = hashlib.md5()
        try:
            f = open(fpath, 'rb')
            try:
                b = f.read(chunk_size)
                while b:
                    h.update(b)
                    b = f.read(chunk_size)
                return base64.b64encode(h.digest())
            finally:
                f.close()
        except:
            return None

    """
    Append the cid=video string to the url query
    """
    def url_cid(self, url):
        """
        """
        ret = url
        o = urlparse.urlparse(url)
        if o.path.startswith('/ermrest/'):
            delimiter = '?'
            try:
                o = urlparse.urlparse(url)
                if o.query != '':
                    delimiter = '&'
                ret = '%s%scid=video' % (url, delimiter)
            except:
                pass
        return ret

    """
    Get the base64 digest strings like the sha256 and the md5 utilities would compute.
    """
    def content_checksum(self, fpath, chunk_size):
        hmd5 = hashlib.md5()
        hsha256 = hashlib.sha256()
        try:
            f = open(fpath, 'rb')
            try:
                b = f.read(chunk_size)
                while b:
                    hmd5.update(b)
                    hsha256.update(b)
                    b = f.read(chunk_size)
                return (base64.b64encode(hmd5.digest()), base64.b64encode(hsha256.digest()))
            finally:
                f.close()
        except:
            return (None, None)

        
